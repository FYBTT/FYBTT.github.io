---
layout: post
title:  "贝叶斯思维——chapter3（估计）"
author: bear
header-img: img/books.jpg
catalog: true
categories: 贝叶斯思维
tags:  python
---

# 3.1 骰子问题
假设我有５颗骰子，分别为4面，6面，8面，12面，20面。
现在我从里面随机选取一个，投掷以后得到6，问最有可能取出的是哪个骰子？

**这里通过3个步骤来解决这个问题：**
1. 选择假设的表示方法
2. 选择数据的表示方法
3. 编写似然度函数

现在我们用[4,6,8,12,20]来表示假设：
```python
suite = Dice([4,6,8,12,20])
```
接下来我们通过骰子掷出的数字作为数据，似然函数如下：
```python
class Dice(Suite):
    def Likelihood(self,data,hypo):#data为得到的投掷结果，hypo是我们的假设
        if hypo < data: #意味着骰子的投掷值要大于骰子的面数，显然这不可能
            return 0
        else #可能情况下得到投掷值的概率自然就是1/hypo
            return 1.0/hypo
```
随着投掷数据的变动，我们可以进一步得到每一个假设的后验概率分布，
先验概率实际上也能看成没有任何事件发生情况下的后验概率。

接下来，如果我们投掷得到6，就相当于：
```
suite.Update(6)
```
![此处输入图片的描述][1]

# 3.2 火车头问题
铁路上以1到N命名火车，有一天你看到一个标号为60的火车头，估计铁路上有多少火车头？
解：可以肯定的是铁路上至少有60个火车头，但这个数字到底是多少？

**我们可以把问题分成两个步骤**：

1. 在得到数据之前，我们对N的认识是什么？（先验概率）
2. 已知一个N的任意值后，得到数据(“标志为60号的火车头”)的似然度？（似然度）

由于缺少前置信息，我们假设，N是从1到1000的等概率的任何值。
```python
hypos = range(1,1000)#假设
```
其实到这里，应该已经看出来了，我们进入到了跟投掷骰子一样的情况里面。编写似然函数：
```python
class Train(Suite):
    def Likelihood(self,data,hypo):#data观察到的火车头编号，hypo是我们的假设
        if hypo < data: #意味着观察到的火车头编号要大于火车数量，显然这不可能
            return 0
        else #可能情况下观察到60号火车头概率自然就是1/hypo
            return 1.0/hypo
```
更新方式如下：
```python
suite = Train(hypos)
suite.Update(60)
```
此时，后去所有假设的可能性可绘制得到：
![此处输入图片的描述][2]

可能性最大化的解是60
不过，这还不是我们的目标;另一个可选的方案是计算**后验概率的平均值分布**,简单点说，就是**期望**：

$$
E(火车数量)＝\sum_{i=1}^nhopy_{火车数量i}P(火车数量i)
$$
可以得到在取假设$[1-1000]$的情况下，我们能得到期望为333。

# 3.3 怎样看待先验概率

如果细看上面的火车头问题的话，会发现我们的假设是非常武断的

1. 我们的假设区间的先验假设是平均分布的
2. 当选择1000作为上界时，期望值是333;
选择500作为上界时，期望值是207;
选择2000为上界时，期望值是552。

**结论：猜测结果对上界敏感**

有两种方法可以进一步减小我们误差：

1. 获取更多的数据。（更多的数据，基于不同的先验分布，后验分布会趋于收敛）
2. 更多的背景资料（先验概率）

就比如，我们看到了3个火车头，分别诉30，60，90。再更新分布可得其期望：

| 上限 | 期望 |
| ------ | ------ |
| 500 | 152 |
| 1000 | 164 |
| 2000 | 171 |

# 3.4 其他先验概率
如果没有更多的数据，我们就需要是通过收集背景资料来优化先验。
事实上，公司规模的分布往往遵循幂律，这项规律表明，如果少于10个火车头的公司有1000家，100个火车头的公司可能有100家，1000个火车头的公司有10家,10000个火车头的公司可能只有1家。

数学上，幂律表示公司数量与公司规模成反比，或：
$$
PMF(x) ∝ (\frac{1}{x})^a
$$
其中$PMF(x)$是$x$的概率密度函数，$a$通常是一个接近于1的参数。

我们可以构造一个服从幂律分布的先验：
```python
#这里继承了Dice，即可以使用Dice的Likelihood函数；重定义__init__函数即可
class Train(Dice):
    def __init__(self, hypos, alpha = 1.0):
        for hypo in hypos:
            self.Set(hypo, hypo**(-alpha))
        self.Normalize()
```
![此处输入图片的描述][3]
考虑了幂律分布作为背景资料以后，我们可以消除大于700的假设。

如果基于这种先验概率，在观察到列车30,60,90时，期望分别是：
| 上限 | 期望 |
| ------ | ------ |
| 500 | 131 |
| 1000 | 133 |
| 2000 | 134 |

事实上，考虑一个任意大的上界，期望都将收敛到134。
所以基于幂律分布的先验概率是比较现实的，因为它是基于公司规模的一些情况，并且在实际中表现更好。

# 3.5 置信区间
一旦计算出了后验分布，通过单点估计或区间对后验分布进行总结通常是有用的。
点估计通常使用平均数、中位数或最大似然值；
区间，我们通常需要计算两个值，使得未知量有90%的可能落在两个值之间。这些值定义了一个置信区间。
计算置信区间的简单做法是在后验概率分布中累加其中的概率，并记录对应与概率5%和95%的值。**简单说就概率密度函数的区间积分值为0.9**。
根据$Pmf$保存的结构，我们只要把概率进行累加即可。
```python
def Percentile(pmf,percentage):
    p = percentage / 100.0
    total = 0
    for val, prob in pmf.Items():
        total += prob
        if total >= p:
            return val
```
这个区间可以如下进行输出：
```python
interval = Percentile(suite,5), Percentile(suite,95)
print interval
```
前面示例中，出现三个火车头，且先验概率呈现幂律分布的火车头问题中$90\%$置信区间为$(91,243)$。如此大的区间确切表明，（尽管期望值已经收敛了）我们任然相当不确定究竟有多少个火车头的存在。

# 3.6 累计分布函数

上一节中，我们为了求算置信区间，两次调用了Percentile函数。如果需要求解多个区间，会导致计算量倍数增长。这里可以进行优化，我们在这里引入**累计分布函数**$(Cdf)$。
由于包含某个分布的相同信息，$Cdf$和$Pmf$某种程度等价，其优点就算可以有效计算百分位数。
thinkbayes.py文件中就提供将$Pmf$转化为$Cdf$的调用：
```python
cdf = suite.MakeCdf()
interval = cdf.Percentile(suite,5), cdf.Percentile(suite,95)
print interval
```

[1]: /img/bayies/3/distribute.png
[2]: /img/bayies/3/train1.png
[3]: /img/bayies/3/train2.png

